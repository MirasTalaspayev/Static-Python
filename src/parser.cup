import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import ast_elements.*;

terminal String PLUS, MINUS, LPAREN, RPAREN, EQUAL, TIMES, DIVIDE, MOD, EXPONENT, FLOOR, COMMA, LESS, LESSEQ, MOREEQ, MORE, NOTEQ, EQEQ;
terminal DEF, COLON, LBRACK, RBRACK, IF, WHILE, FOR, RANGE, IN, PRINT, RETURN, OI, CI;
terminal String LABEL, STRING;
terminal Integer NUMBER;
terminal Float FLOAT;
terminal Boolean TRUE, FALSE;

non terminal Boolean bool;
non terminal String bin_op1, bin_op2, cond_sign, variable_type;

non terminal ProgramAST program;
non terminal Expression expr0, expr1, expr2, expr3, term, expr, value;
non terminal List<Statement> stmt_list;
non terminal Statement stmt;
non terminal fucn_dec;


start with program;

program	::= stmt_list:sl												{: RESULT = new ProgramAST(sl); :};

stmt_list ::= stmt_list:sl stmt:st										{: RESULT = sl; RESULT.add(st); :}
		| stmt:st 														{: RESULT = new ArrayList<Statement>(); RESULT.add(st); :};

stmt 	::= LABEL:var_name COLON variable_type:var_type EQUAL value:ex	{: RESULT = new ValueDeclaration(var_name, var_type, ex); :}
		| LABEL:var_name COLON variable_type:var_type					{: RESULT = new ValueDeclaration(var_name, var_type, null); :}
		| LABEL:var_name EQUAL value:ex									{: RESULT = new Assignment(var_name, ex); :}
		| DEF LABEL:func_name LPAREN fucn_dec RPAREN COLON
			OI stmt_list:sl CI											{: RESULT = new FunctionDeclaration(func_name, ex, sl); :}
		| LABEL:func_name LPAREN expr:ex RPAREN							{: RESULT = new FunctionCall(func_name, ex); :}
		| IF expr:ex COLON OI stmt_list:sl CI 							{: RESULT = new IfStatement(ex, sl); :}
		| WHILE expr:ex COLON OI stmt_list:sl CI						{: RESULT = new WhileLoop(ex, sl); :}
		| FOR LABEL:var_name COLON LABEL:var_type IN expr:ex COLON
			OI stmt_list:sl CI											{: RESULT = new ForLoop(var_name, var_type, ex, sl); :}
		| PRINT LPAREN expr:ex RPAREN									{: RESULT = new Print(ex); :}
		| RETURN expr:ex												{: RESULT = new Return(ex); :};

variable_type ::= LABEL:var_type							{: RESULT = var_type; :}
		| LABEL:strct_type LBRACK LABEL:var_type RBRACK		{: RESULT = var_type; :};

value ::= expr:ex											{: RESULT = ex; :}
		| LBRACK expr:ex RBRACK								{: RESULT = ex; :};

fucn_dec ::= fucn_dec COMMA LABEL:var_name COLON variable_type:var_type		{: RESULT = ex; :}
		| LABEL COLON variable_type											{: RESULT = ex; :}


cond_sign ::= EQEQ:op						{: RESULT = op; :}
		| NOTEQ:op							{: RESULT = op; :}
		| LESS:op							{: RESULT = op; :}
		| LESSEQ:op							{: RESULT = op; :}
		| MORE:op							{: RESULT = op; :}
		| MOREEQ:op							{: RESULT = op; :};

bin_op1	::= PLUS:op							{: RESULT = op; :}
		| MINUS:op							{: RESULT = op; :};

bin_op2 ::= TIMES:op						{: RESULT = op; :}
		| DIVIDE:op							{: RESULT = op; :}
		| MOD:op							{: RESULT = op; :}
		| EXPONENT:op						{: RESULT = op; :}
		| FLOOR:op							{: RESULT = op; :};

expr 	::= expr0:e0								{: System.out.println("expr = " + e0); RESULT = e0; :}
		| expr_list:e_list							{: RESULT = e_list; :};

expr0 	::= expr0:e0 cond_sign:op expr1:e1			{: RESULT = new ComparisonOperator(e0, op, e1); :}
        | expr1:e1 									{: RESULT = e1; :};

expr1 	::= expr1:e1 bin_op1:op expr2:e2			{: RESULT = new BinaryOperator(e1, op, e2); :}
		| expr2:e2 									{: RESULT = e2; :};

expr2 	::= expr2:e2 bin_op2:op term:e3				{: RESULT = new BinaryOperator(e2, op, e3); :}
		| term:e3									{: RESULT = e3; :};

expr_list ::= LBRACK expr_values:e1 RBRACK 			{: RESULT = new ListExpression(e1); :}
		| LBRACK RBRACK								{: RESULT = new ListExpression(new ArrayList<Expression>()); :};

expr_values ::= expr_values:ex_vals COMMA expr:e2 	{: RESULT = ex_vals; RESULT.add(e2); :}
		| expr:e 									{: RESULT = new ArrayList<Expression>(); RESULT.add(e); :};

term 	::= LPAREN expr:ex RPAREN					{: RESULT = ex; :}
		| NUMBER:n									{: RESULT = new NumberExpression(n); :}
		| bool:b									{: RESULT = new BooleanExpression(b); :}
		| LABEL:l									{: RESULT = new LabelExpression(l); :}
		| STRING:s									{: RESULT = new StringExpression(s); :}
		| FLOAT:f									{: RESULT = new FloatExpression(f); :};

bool 	::= TRUE 
		| FALSE;